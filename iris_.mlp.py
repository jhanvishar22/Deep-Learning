# -*- coding: utf-8 -*-
"""JhanviSharma_irismlp_DL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HpbflCM6xxMJcTY5M3lq-I_T5G4D3jjE
"""

import torch
import random
import numpy as np
import pandas as pd
from torch.autograd import Variable
from sklearn.metrics import accuracy_score, precision_score, recall_score

torch.manual_seed(0)
random.seed(0)
np.random.seed(0)
torch.use_deterministic_algorithms(True)

from matplotlib import pyplot as plt
from torchvision import datasets
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F

iristrain = pd.read_csv('iris_training.csv', header=None, names=["Sepal_length","Sepal_width","Petal_length","Petal_width","Species"])
iristrain.shape

iristest = pd.read_csv('iris_test.csv', header=None, names=["Sepal_length","Sepal_width","Petal_length","Petal_width","Species"])
iristest.shape

xiristrain = iristrain.drop(["Species"],axis=1).values
yiristrain= iristrain["Species"].values

xiristest = iristest.drop(["Species"],axis=1).values
yiristest = iristest["Species"].values

txiristrain = Variable(torch.Tensor(xiristrain).float())
tyiristrain = Variable(torch.Tensor(yiristrain).long())

txiristest = Variable(torch.Tensor(xiristest).float())
tyiristest = Variable(torch.Tensor(yiristest).long())

class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(4,5)        
        self.fc2 = nn.Linear(5,10) 
        self.fc3 = nn.Linear(10,5)
        self.fc4 = nn.Linear(5,3)  
    def forward(self, x):
        
        
        x = F.softmax(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = F.relu(self.fc3(x))
        x = F.relu(self.fc4(x))
        return x

## initializing nn

jsdevice = torch.device('cpu' if not torch.cuda.is_available() else 'cuda')
jsmodel = Net().to(jsdevice)
print(jsmodel)

## Specifying the loss function

losscriteria = nn.CrossEntropyLoss().to(jsdevice)

## Specifying the optimizer

jsoptimizer = torch.optim.SGD(jsmodel.parameters(), lr=0.3)
print(losscriteria, jsoptimizer)

## Specifying the loss function

losscriteria = nn.CrossEntropyLoss().to(jsdevice)

## Specifying the optimizer

adamoptimizer = torch.optim.Adam(jsmodel.parameters(), lr=0.003)

print(losscriteria, adamoptimizer)

for epoch in range(5):
    # For forward pass, Computing predicted y by passing x in the model
    ytrainpred = jsmodel(txiristrain)
    loss = losscriteria(ytrainpred, tyiristrain)
    print('Number of epochs', epoch, 'Computed loss', loss.item())

    jsoptimizer.zero_grad()
    
    loss.backward()
    
    jsoptimizer.step()

for epoch in range(10):
    # FOr forward pass, Computing predicted y by passing x in the model
    ytrainpred = jsmodel(txiristrain)
    loss = losscriteria(ytrainpred, tyiristrain)

    print('Number of epochs is ', epoch, 'loss is', loss.item())

    adamoptimizer.zero_grad()

    loss.backward()

    adamoptimizer.step()

testirispred=jsmodel(txiristest)


_, predictirisy = torch.max(testirispred, 1)

print(tyiristest)
print(predictirisy)

## printing acuracy, precision and Mirco and Macro recall
accuracy = accuracy_score(tyiristest, predictirisy)
mpiris = precision_score(tyiristest, predictirisy, average='micro')
mariris =  recall_score(tyiristest, predictirisy, average='macro')
miriris = recall_score(tyiristest, predictirisy, average='micro')

print('Accuracy', accuracy )
print('Micro Precision', mpiris )
print('Macro Recall', mariris)
print('Micro Recall', miriris)



