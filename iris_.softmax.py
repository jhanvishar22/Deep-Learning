# -*- coding: utf-8 -*-
"""JhanviSharma_irissoftmax_DL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oINF-hUWiCiZheWukplORlKbe_E6rKPy
"""

import torch
import random
import numpy as np
import pandas as pd
from torch.autograd import Variable
from sklearn.metrics import accuracy_score, precision_score, recall_score

torch.manual_seed(0)
random.seed(0)
np.random.seed(0)
torch.use_deterministic_algorithms(True)

from matplotlib import pyplot as plt
from torchvision import datasets
import torchvision.transforms as transforms
import torch.nn as nn
import torch.nn.functional as F

iristrain = pd.read_csv('iris_training.csv', header=None, names=["Sepal_length","Sepal_width","Petal_length","Petal_width","Species"])
iristrain.shape

iristest = pd.read_csv('iris_test.csv', header=None, names=["Sepal_length","Sepal_width","Petal_length","Petal_width","Species"])
iristest.shape

xiristrain = iristrain.drop(["Species"],axis=1).values
yiristrain= iristrain["Species"].values

xiristest = iristest.drop(["Species"],axis=1).values
yiristest = iristest["Species"].values

txiristrain = Variable(torch.Tensor(xiristrain).float())
tyiristrain = Variable(torch.Tensor(yiristrain).long())

txiristest = Variable(torch.Tensor(xiristest).float())
tyiristest = Variable(torch.Tensor(yiristest).long())

class Net(nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.fc1 = nn.Linear(4,3)        
       
    def forward(self, x):
        
        # add hidden layer, with softmax activation function
        x = F.softmax(self.fc1(x))
        return x

## Initializing the nn

irisdevice = torch.device('cpu' if not torch.cuda.is_available() else 'cuda')
irismodel = Net().to(irisdevice)
print(irismodel)

## specifying the loss function

iriscriteria = nn.CrossEntropyLoss().to(irisdevice)

## specifying optimizer

sgdoptimizer = torch.optim.SGD(irismodel.parameters(), lr=0.3)
print(iriscriteria, sgdoptimizer)

## SPecifying loss function

iriscriteria = nn.CrossEntropyLoss().to(irisdevice)

## Specifying optimizer function

adamoptimizer = torch.optim.Adam(irismodel.parameters(), lr=0.003)

print(iriscriteria, adamoptimizer)

for epoch in range(10):
    # For forward pass, Computing predicted y by passing x in the model
    yirispred = irismodel(txiristrain)

    # Computing loss
    irisloss = iriscriteria(yirispred, tyiristrain)

    print('Number of epochs is', epoch, 'loss is', irisloss.item())

    sgdoptimizer.zero_grad()

    irisloss.backward()

    sgdoptimizer.step()

for epoch in range(10):
    # For forward pass, Compute predicted y by passing x in the model
    yirispred = irismodel(txiristrain)

    # Computing loss
    irisloss = iriscriteria(yirispred, tyiristrain)

    print('number of epochs is ', epoch, 'loss is ', irisloss.item())

    adamoptimizer.zero_grad()

    irisloss.backward()

    adamoptimizer.step()

testirispred = irismodel(txiristest)

_, predictirisy = torch.max(testirispred, 1)

print(tyiristest)
print(predictirisy)

accuracy = accuracy_score(tyiristest, predictirisy)
mpiris = precision_score(tyiristest, predictirisy, average='micro')
mariris =  recall_score(tyiristest, predictirisy, average='macro')
miriris = recall_score(tyiristest, predictirisy, average='micro')

print('Accuracy', accuracy )
print('Micro precision', mpiris )
print('Macro recall', mariris)
print('Micro recall', miriris)

